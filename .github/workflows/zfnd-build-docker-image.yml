# This workflow automates the building and pushing of Docker images based on user-defined inputs. It includes:
# - Accepting various inputs like image name, Dockerfile path, target, and additional Rust-related parameters.
# - Authenticates with Google Cloud and logs into Google Artifact Registry and DockerHub.
# - Uses Docker Buildx for improved build performance and caching.
# - Builds the Docker image and pushes it to both Google Artifact Registry and potentially DockerHub, depending on release type.
# - Manages caching strategies to optimize build times across different branches.
# - Uses Docker Scout to display vulnerabilities and recommendations for the latest built image.
name: Build docker image

on:
  workflow_call:
    inputs:
      image_name:
        required: true
        type: string
      dockerfile_path:
        required: true
        type: string
      dockerfile_target:
        required: true
        type: string
      short_sha:
        description: "Git short SHA to embed in the build. Defaults to GITHUB_SHA_SHORT. Pass empty string to disable."
        required: false
        type: string
        default: auto
      rust_backtrace:
        required: false
        type: string
      rust_lib_backtrace:
        required: false
        type: string
      # defaults to: vars.RUST_LOG
      rust_log:
        required: false
        type: string
      features:
        required: false
        type: string
      no_cache:
        description: Disable the Docker cache for this build
        required: false
        type: boolean
        default: false
      publish_to_dockerhub:
        description: "Whether to publish to Docker Hub. Set to true only in release-binaries.yml to create official production images. Defaults to false to prevent duplicate publishing from deploy-nodes.yml."
        required: false
        type: boolean
        default: false
      environment:
        description: "Environment to use for the build (commonly dev)"
        required: false
        type: string
        default: dev

    secrets:
      DOCKERHUB_USERNAME:
        required: false
      DOCKERHUB_TOKEN:
        required: false

    outputs:
      image_digest:
        description: The image digest to be used on a caller workflow
        value: ${{ jobs.merge.outputs.image_digest }}

permissions:
  contents: read

env:
  FEATURES: ${{ inputs.features }}
  RUST_LOG: ${{ inputs.rust_log || vars.RUST_LOG }}
  CARGO_INCREMENTAL: ${{ vars.CARGO_INCREMENTAL }}

jobs:
  prepare-matrix:
    name: Prepare build matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Set build matrix
        id: set-matrix
        run: |
          # Runners are configurable via repository variables to allow larger runners
          # for ZcashFoundation (more disk space) while forks use default runners.
          AMD64_RUNNER="${{ vars.DOCKER_BUILD_RUNNER_AMD64 || 'ubuntu-latest' }}"
          ARM64_RUNNER="${{ vars.DOCKER_BUILD_RUNNER_ARM64 || 'ubuntu-24.04-arm' }}"

          # Runtime builds: AMD64 + ARM64 (multi-arch)
          # Other targets: AMD64 only (lightwalletd dependency)
          if [[ "${{ inputs.dockerfile_target }}" == "runtime" ]]; then
            MATRIX='{"include":[{"platform":"linux/amd64","runner":"'"$AMD64_RUNNER"'"},{"platform":"linux/arm64","runner":"'"$ARM64_RUNNER"'"}]}'
          else
            MATRIX='{"include":[{"platform":"linux/amd64","runner":"'"$AMD64_RUNNER"'"}]}'
          fi
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Runners: AMD64=$AMD64_RUNNER, ARM64=$ARM64_RUNNER"
          echo "Platforms: $(echo $MATRIX | jq -r '.include[].platform' | paste -sd ',' -)"

  build:
    name: Build images (${{ matrix.platform }})
    needs: prepare-matrix
    timeout-minutes: 210
    runs-on: ${{ matrix.runner }}
    environment: ${{ github.event_name == 'release' && 'prod' || inputs.environment || 'dev' }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.prepare-matrix.outputs.matrix) }}
    outputs:
      image_digest: ${{ steps.docker_build.outputs.digest || steps.docker_build_no_attestations.outputs.digest }}
      image_name: ${{ fromJSON(steps.docker_build.outputs.metadata || steps.docker_build_no_attestations.outputs.metadata)['image.name'] }}
    permissions:
      contents: read
      id-token: write
      pull-requests: write # for `docker-scout` to be able to write the comment
    env:
      DOCKER_BUILD_SUMMARY: ${{ vars.DOCKER_BUILD_SUMMARY }}
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd #v5.0.1
        with:
          persist-credentials: false

      - name: Inject slug/short variables
        uses: rlespinasse/github-slug-action@c33ff65466c58d57e4d796f88bb1ae0ff26ee453 #v5.2.0
        with:
          short-length: 7

      # Automatic tag management and OCI Image Format Specification for labels
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@c1e51972afc2121e065aed6d45c65596fe445f3f #v5.8.0
        with:
          # list of Docker images to use as base name for tags
          # Docker Hub publishing requires ALL conditions to be true:
          # - inputs.publish_to_dockerhub must be explicitly set to true (defaults to false)
          # - Event must be a release (not a pre-release)
          # This prevents duplicate publishing when both release-binaries.yml and deploy-nodes.yml run
          # Ref: https://github.com/orgs/community/discussions/26281#discussioncomment-3251177
          images: |
            us-docker.pkg.dev/${{ vars.GCP_PROJECT }}/zebra/${{ inputs.image_name }}
            zfnd/${{ inputs.image_name }},enable=${{ inputs.publish_to_dockerhub && github.event_name == 'release' && !github.event.release.prerelease }}
          # generate Docker tags based on the following events/attributes
          tags: |
            # These DockerHub release tags support the following use cases:
            # - `latest`: Automatically points to the most recent Zebra release, ensuring users always get the latest stable version when pulling or updating.
            # - `1.x.y`: Represents a specific semantic version (e.g., 1.2.3), allowing users to pin to an exact version for stability, preventing automatic upgrades.
            #
            type=semver,pattern={{version}}
            # CI-only tags (not published to DockerHub, only in Google Artifact Registry):
            # - `pr-xxx`: Tags images with the pull request number for CI tracking during PR workflows.
            # - `branch-name`: Tags images with the branch name (e.g., `main`, `dev`) for CI builds on branch pushes.
            # - `edge`: Tags the latest build on the default branch (e.g., `main`), used in CI to represent the cutting-edge version for testing.
            # - `schedule`: Tags images built during scheduled workflows (e.g., nightly or periodic builds) for CI monitoring and testing.
            type=ref,event=pr
            type=ref,event=branch
            type=edge,enable={{is_default_branch}}
            type=schedule
            # - `sha-xxxxxx`: Uses the commit SHA (shortened) to tag images for precise identification.
            # Applied during pull requests and branch pushes to ensure CI tests use the exact image from the last commit.
            type=sha,event=pr
            type=sha,event=branch

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@7c6bc770dae815cd3e89ee6cdf493a5fab2cc093 #v3.0.0
        with:
          workload_identity_provider: "${{ vars.GCP_WIF }}"
          service_account: "${{ vars.GCP_ARTIFACTS_SA }}"
          token_format: access_token
          # Some builds might take over an hour, and Google's default lifetime duration for
          # an access token is 1 hour (3600s). We increase this to 3 hours (10800s)
          # as some builds take over an hour.
          access_token_lifetime: 10800s

      - name: Login to Google Artifact Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef #v3.6.0
        with:
          registry: us-docker.pkg.dev
          username: oauth2accesstoken
          password: ${{ steps.auth.outputs.access_token }}

      - name: Login to DockerHub
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef #v3.6.0
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Setup Docker Buildx to use Docker Build Cloud
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 #v3.11.1
        with:
          version: lab:latest
          driver: ${{ vars.DOCKER_BUILDER || 'docker' }}
          endpoint: zfnd/zebra

      # Build and push image by digest to Google Artifact Registry
      # Images are pushed by digest only and will be merged into multi-arch manifest in the merge job
      # With provenance and SBOM (ZcashFoundation repository only)
      - name: Build & push (with attestations)
        id: docker_build
        if: github.repository_owner == 'ZcashFoundation'
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 #v6.18.0
        with:
          platforms: ${{ matrix.platform }}
          target: ${{ inputs.dockerfile_target }}
          context: .
          file: ${{ inputs.dockerfile_path }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            SHORT_SHA=${{ inputs.short_sha == 'auto' && env.GITHUB_SHA_SHORT || inputs.short_sha }}
            RUST_LOG=${{ env.RUST_LOG }}
            CARGO_INCREMENTAL=${{ env.CARGO_INCREMENTAL }}
            FEATURES=${{ env.FEATURES }}
          outputs: type=image,name=us-docker.pkg.dev/${{ vars.GCP_PROJECT }}/zebra/${{ inputs.image_name }},push-by-digest=true,name-canonical=true,push=true
          # It's recommended to build images with max-level provenance attestations
          # https://docs.docker.com/build/ci/github-actions/attestations/
          provenance: mode=max
          sbom: true
          # Don't read from the cache if the caller disabled it.
          # https://docs.docker.com/engine/reference/commandline/buildx_build/#options
          no-cache: ${{ inputs.no_cache }}

      # Build and push image by digest without attestations (contributor forks)
      # Images are pushed by digest only and will be merged into multi-arch manifest in the merge job
      - name: Build & push (without attestations)
        id: docker_build_no_attestations
        if: github.repository_owner != 'ZcashFoundation'
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 #v6.18.0
        with:
          platforms: ${{ matrix.platform }}
          target: ${{ inputs.dockerfile_target }}
          context: .
          file: ${{ inputs.dockerfile_path }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            SHORT_SHA=${{ inputs.short_sha == 'auto' && env.GITHUB_SHA_SHORT || inputs.short_sha }}
            RUST_LOG=${{ env.RUST_LOG }}
            CARGO_INCREMENTAL=${{ env.CARGO_INCREMENTAL }}
            FEATURES=${{ env.FEATURES }}
          outputs: type=image,name=us-docker.pkg.dev/${{ vars.GCP_PROJECT }}/zebra/${{ inputs.image_name }},push-by-digest=true,name-canonical=true,push=true
          # Don't read from the cache if the caller disabled it.
          # https://docs.docker.com/engine/reference/commandline/buildx_build/#options
          no-cache: ${{ inputs.no_cache }}

      # Export digest for multi-arch manifest merge
      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.docker_build.outputs.digest || steps.docker_build_no_attestations.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      # Upload digest as artifact for merge job
      - name: Upload digest
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 #v5.0.0
        with:
          name: digests-${{ matrix.platform == 'linux/amd64' && 'amd64' || 'arm64' }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  # Merge multi-platform manifests and apply tags
  # This job creates a multi-arch manifest from all platform-specific images built in parallel
  # and applies all necessary tags to both GCP Artifact Registry and DockerHub
  merge:
    name: Create multi-arch manifest
    runs-on: ubuntu-latest
    needs: [prepare-matrix, build]
    environment: ${{ github.event_name == 'release' && 'prod' || inputs.environment || 'dev' }}
    permissions:
      contents: read
      id-token: write
      pull-requests: write
    outputs:
      image_digest: ${{ steps.create.outputs.digest }}
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd #v5.0.1
        with:
          persist-credentials: false

      - name: Inject slug/short variables
        uses: rlespinasse/github-slug-action@c33ff65466c58d57e4d796f88bb1ae0ff26ee453 #v5.2.0
        with:
          short-length: 7

      # Download all platform digests
      - name: Download digests
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 #v5.0.0
        with:
          path: /tmp/digests
          pattern: digests-*
          merge-multiple: true

      # Docker meta for tag generation
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@c1e51972afc2121e065aed6d45c65596fe445f3f #v5.8.0
        with:
          images: |
            us-docker.pkg.dev/${{ vars.GCP_PROJECT }}/zebra/${{ inputs.image_name }}
            zfnd/${{ inputs.image_name }},enable=${{ inputs.publish_to_dockerhub && github.event_name == 'release' && !github.event.release.prerelease }}
          tags: |
            type=semver,pattern={{version}}
            type=ref,event=pr
            type=ref,event=branch
            type=edge,enable={{is_default_branch}}
            type=schedule
            type=sha,event=pr
            type=sha,event=branch

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@7c6bc770dae815cd3e89ee6cdf493a5fab2cc093 #v3.0.0
        with:
          workload_identity_provider: "${{ vars.GCP_WIF }}"
          service_account: "${{ vars.GCP_ARTIFACTS_SA }}"
          token_format: access_token
          access_token_lifetime: 3600s

      - name: Login to Google Artifact Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef #v3.6.0
        with:
          registry: us-docker.pkg.dev
          username: oauth2accesstoken
          password: ${{ steps.auth.outputs.access_token }}

      - name: Login to DockerHub
        if: inputs.publish_to_dockerhub && github.event_name == 'release' && !github.event.release.prerelease
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef #v3.6.0
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Create multi-arch manifest and push to registries
      - name: Create manifest and push
        id: create
        working-directory: /tmp/digests
        run: |
          # Create array of image references from digests
          docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf 'us-docker.pkg.dev/${{ vars.GCP_PROJECT }}/zebra/${{ inputs.image_name }}@sha256:%s ' *)

          # Get digest of the merged manifest
          docker buildx imagetools inspect us-docker.pkg.dev/${{ vars.GCP_PROJECT }}/zebra/${{ inputs.image_name }}:${{ steps.meta.outputs.version }} \
            --format '{{json .Manifest}}' | jq -r '.digest' | tee /tmp/digest.txt
          echo "digest=$(cat /tmp/digest.txt)" >> $GITHUB_OUTPUT
        env:
          DOCKER_METADATA_OUTPUT_JSON: ${{ steps.meta.outputs.json }}

      # For the merged multi-arch manifest, display:
      # - the vulnerabilities (ignoring the base image, and only displaying vulnerabilities with a critical or high security severity)
      # - the available recommendations
      # - compare it to the latest image indexed in Docker Hub (only displaying changed packages and vulnerabilities that already have a fix)
      #
      # Record the image to Scout environment based on the event type, for example:
      # - `prod` for a release event
      # - `stage` for a push event to the main branch
      # - `dev` for a pull request event
      - name: Docker Scout
        id: docker-scout
        uses: docker/scout-action@f8c776824083494ab0d56b8105ba2ca85c86e4de #v1.18.2
        # We only run Docker Scout on the `runtime` target, as the other targets are not meant to be released
        # and are commonly used for testing, and thus are ephemeral.
        # TODO: Remove the `contains` check once we have a better way to determine if just new vulnerabilities are present.
        # See: https://github.com/docker/scout-action/issues/56
        if: ${{ inputs.dockerfile_target == 'runtime' && contains(github.event.pull_request.title, 'Release v') }}
        with:
          command: cves,recommendations,compare,environment
          image: us-docker.pkg.dev/${{ vars.GCP_PROJECT }}/zebra/${{ inputs.image_name }}:${{ steps.meta.outputs.version }}
          to: zfnd/zebra:latest
          ignore-base: true
          ignore-unchanged: true
          only-fixed: true
          only-severities: critical,high
          environment: ${{ (github.event_name == 'release' && !github.event.release.prerelease && 'prod') || (github.event_name == 'push' && github.ref_name == 'main' && 'stage') || (github.event_name == 'pull_request' && 'dev') }}
          organization: zfnd
          github-token: ${{ secrets.GITHUB_TOKEN }} # to be able to write the comment
